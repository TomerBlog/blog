<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>EntraGoat Scenario 2: Exploiting App-Only Graph Permissions in Entra ID | TomerN</title>
<meta name="keywords" content="">
<meta name="description" content="Graph Me the Crown (and Roles)
EntraGoat Scenario 2 demonstrates how certificate-based authentication tied to an existing service principal and overprivileged application permissions can lead to Global Administrator compromise.
The attacker starts with access to a leaked certificate that was exposed through continuous integration/continuous delivery (CI/CD) pipeline artifacts. The certificate is valid for a service principal that has the AppRoleAssignment.ReadWrite.All application permission.
By authenticating in an app-only context, the attacker abuses this permission to assign another permission, RoleManagement.ReadWrite.Directory, to the same service principal. This enables the service principal to self-assign any directory role (including Global Administrator) to any service principal it wishes. Finally, the attacker resets the admin’s password and retrieves the scenario flag.">
<meta name="author" content="Tomer Nahum, Jonathan Elkabas">
<link rel="canonical" href="http://localhost:1313/posts/scenario2/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fed13c992360e4d7010e740c7b8d87665399d4995b4155fa8c51ba9957c69fb4.css" integrity="sha256-/tE8mSNg5NcBDnQMe42HZlOZ1JlbQVX6jFG6mVfGn7Q=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/scenario2/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><html>

<body>

</body>
</html><meta property="og:url" content="http://localhost:1313/posts/scenario2/">
  <meta property="og:site_name" content="TomerN">
  <meta property="og:title" content="EntraGoat Scenario 2: Exploiting App-Only Graph Permissions in Entra ID">
  <meta property="og:description" content="Graph Me the Crown (and Roles) EntraGoat Scenario 2 demonstrates how certificate-based authentication tied to an existing service principal and overprivileged application permissions can lead to Global Administrator compromise.
The attacker starts with access to a leaked certificate that was exposed through continuous integration/continuous delivery (CI/CD) pipeline artifacts. The certificate is valid for a service principal that has the AppRoleAssignment.ReadWrite.All application permission.
By authenticating in an app-only context, the attacker abuses this permission to assign another permission, RoleManagement.ReadWrite.Directory, to the same service principal. This enables the service principal to self-assign any directory role (including Global Administrator) to any service principal it wishes. Finally, the attacker resets the admin’s password and retrieves the scenario flag.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-08-10T00:14:27+03:00">
    <meta property="article:modified_time" content="2025-08-10T00:14:27+03:00">
      <meta property="og:image" content="http://localhost:1313/images/tomer.jpg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/images/tomer.jpg">
<meta name="twitter:title" content="EntraGoat Scenario 2: Exploiting App-Only Graph Permissions in Entra ID">
<meta name="twitter:description" content="Graph Me the Crown (and Roles)
EntraGoat Scenario 2 demonstrates how certificate-based authentication tied to an existing service principal and overprivileged application permissions can lead to Global Administrator compromise.
The attacker starts with access to a leaked certificate that was exposed through continuous integration/continuous delivery (CI/CD) pipeline artifacts. The certificate is valid for a service principal that has the AppRoleAssignment.ReadWrite.All application permission.
By authenticating in an app-only context, the attacker abuses this permission to assign another permission, RoleManagement.ReadWrite.Directory, to the same service principal. This enables the service principal to self-assign any directory role (including Global Administrator) to any service principal it wishes. Finally, the attacker resets the admin’s password and retrieves the scenario flag.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "EntraGoat Scenario 2: Exploiting App-Only Graph Permissions in Entra ID",
      "item": "http://localhost:1313/posts/scenario2/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "EntraGoat Scenario 2: Exploiting App-Only Graph Permissions in Entra ID",
  "name": "EntraGoat Scenario 2: Exploiting App-Only Graph Permissions in Entra ID",
  "description": "Graph Me the Crown (and Roles) EntraGoat Scenario 2 demonstrates how certificate-based authentication tied to an existing service principal and overprivileged application permissions can lead to Global Administrator compromise.\nThe attacker starts with access to a leaked certificate that was exposed through continuous integration/continuous delivery (CI/CD) pipeline artifacts. The certificate is valid for a service principal that has the AppRoleAssignment.ReadWrite.All application permission.\nBy authenticating in an app-only context, the attacker abuses this permission to assign another permission, RoleManagement.ReadWrite.Directory, to the same service principal. This enables the service principal to self-assign any directory role (including Global Administrator) to any service principal it wishes. Finally, the attacker resets the admin’s password and retrieves the scenario flag.\n",
  "keywords": [
    
  ],
  "articleBody": "Graph Me the Crown (and Roles) EntraGoat Scenario 2 demonstrates how certificate-based authentication tied to an existing service principal and overprivileged application permissions can lead to Global Administrator compromise.\nThe attacker starts with access to a leaked certificate that was exposed through continuous integration/continuous delivery (CI/CD) pipeline artifacts. The certificate is valid for a service principal that has the AppRoleAssignment.ReadWrite.All application permission.\nBy authenticating in an app-only context, the attacker abuses this permission to assign another permission, RoleManagement.ReadWrite.Directory, to the same service principal. This enables the service principal to self-assign any directory role (including Global Administrator) to any service principal it wishes. Finally, the attacker resets the admin’s password and retrieves the scenario flag.\nThis scenario emphasizes the risks of certificate sprawl, overprivileged Graph scopes, and the nature of app-only tokens. It also highlights the distinction between permission enforcement via token claims vs. real-time directory evaluation, which we’ll explain in this walkthrough.\nAttack path overview Initial foothold: The attacker obtains a base64-encoded certificate and its password, reportedly leaked through CI/CD pipeline reconnaissance. Identification: The certificate matches an existing service principal named Corporate Finance Analytics. Permission abuse: The attacker authenticates using the certificate and discovers that the service principal has AppRoleAssignment.ReadWrite.All application permission. Privilege escalation: The attacker uses this permission to assign RoleManagement.ReadWrite.Directory to the same service principal. Role takeover: With directory role management access, the attacker adds the service principal as a member of the Global Administrator directory role. Account compromise: The attacker resets the Global Admin user’s password and authenticates to retrieve the flag. Attack flow Figure 1 shows the flow of this attack.\nFigure 1. Flow of the Graph Me the Crown (and Roles) attack scenario\nHow does this attack bypass normal authentication controls? This scenario abuses Microsoft Entra ID’s application model, where apps consist of a global registration and a tenant-local service principal. App-only permissions are requested at the application registration level and granted at the service principal level. In addition, service principals can authenticate independently of users using the OAuth 2.0 client credentials flow.\nWhen a valid certificate is registered for a service principal (at its keyCredentials.customKeyIdentifier property), it can be used to authenticate without interactive input or multifactor authentication (MFA). This app-only authentication path operates outside user-centric protections, allowing a compromised certificate to directly access Graph APIs with the permissions or roles assigned to the service principal.\nThis attack path combines:\nWeak certificate hygiene (less relevant for Entra ID) Excessive and unmonitored app permissions The intentional design of AppRoleAssignment.ReadWrite.All to bypass* the admin consent experience in app-only contexts By chaining these conditions, attackers can authenticate as a service principal, escalate to sensitive Graph scopes like RoleManagement.ReadWrite.Directory to grant themselves a privileged role (up to Global Administrator) without ever touching a user session after they gained the service principal’s credentials.\n____\nNote: Additional attack paths can be chained to this one, as any identity with Application Administrator or Cloud Application Administrator roles, or any service principal with the Application.ReadWrite.All app role or ownership over the target service principal—as demonstrated in Scenario 1—can also take advantage of this attack path by adding credentials for backdoor access to the service principal.\n____\nFinally, it’s important to distinguish between different uses of certificate-based authentication (CBA). When CBA configuration is disabled at the tenant level, that restriction applies only to interactive user authentication—not OAuth client assertions flow for applications. Service principals can still authenticate using certificates if a valid credential is registered in their KeyCredentials property. Entra ID treats this as a separate authentication mechanism. This architectural decoupling may lead to false assumptions about the enforcement of tenant-wide certificate policies.\n*In fact, this permission doesn’t “bypass” admin consent - it IS admin consent. The permission itself requires admin consent to be granted initially, then enables the holder (and adversaries, of course) to programmatically grant consent to other applications as part of machine-to-machine interaction.\nHow to detect and defend against misuse of app-only authentication Defensive posture in Entra ID must focus on restricting the use of broad app permissions and closely monitoring service principals that hold sensitive roles like AppRoleAssignment.ReadWrite.All and RoleManagement.ReadWrite.Directory.\nSecurity teams should:\nRegularly audit service principals for high-privilege app roles Track creation of new credentials on service principals, especially when done outside approved automation Detect changes to app role assignments that could allow privilege escalation Scenario deep dive: Step-by-step solution walkthrough Let’s take a look at the steps to simulate bypass of authentication controls and understand how it enables Global Admin compromise.\nStep 1: Initial foothold with a compromised certificate We begin Scenario 2 with a compromised certificate (Figure 2), allegedly dumped during CI/CD pipeline reconnaissance. It’s base64-encoded, password-protected, and left behind like cargo falling off a DevOps truck.\nFigure 2. A compromised certificate, dumped in our lap\nTo identify the owner of the certificate, we first decode it into a usable X509Certificate2 object and inspect its metadata:\n1 2 3 4 5 6 7 8 9 $certBase64 = \"[BASE64\\_CERTIFICATE\\_BLOG]\" $certPassword = \"GoatAccess!123\" $certBytes = [System.Convert]::FromBase64String($certBase64) $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($certBytes, $certPassword, [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable) $cert | Select-Object Subject, Issuer, Thumbprint, NotBefore, NotAfter | Format-List We can see that the certificate is self-signed and issued for an app called Corporate Finance Analytics (Figure 3).\nFigure 3. Identifying the app our certificate is issued for\nAlternatively, we can iterate through all application registrations in the tenant and search for a matching certificate thumbprint. Each application object in Entra ID has a KeyCredentials attribute, which holds metadata about certificates or public keys associated with the app that is used for authentication in app-only contexts. Each entry includes a CustomKeyIdentifier, which stores the certificate’s thumbprint (Figure 4) in binary form and allows for lookup or correlation against known certificates.\nFigure 4. Certificate thumbprint\nThe following function can perform the search:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 function Find-AppRegistrationByThumbprint { param([string]$Thumbprint) # Get all application registrations and check for matching certificate thumbprint $allApps = Get-MgApplication -All foreach ($app in $allApps) { if ($app.KeyCredentials) { foreach ($keyCred in $app.KeyCredentials) { # Compare thumbprints (certificate matching) if ($keyCred.CustomKeyIdentifier) { $credThumbprint = [System.Convert]::ToHexString($keyCred.CustomKeyIdentifier) if ($credThumbprint -eq $Thumbprint) { Write-Host \"Certificate match found for: $($app.DisplayName)\" -ForegroundColor Cyan return $app } } } } } return $null } Microsoft Graph never stores or returns the actual certificate content or private keys. Querying the KeyCredential attribute using Graph API only reveals the registered certificate metadata, never the certificate itself, no matter how high the privileges the requesting identity has. This reinforces the critical need for secure handling and storage of private keys throughout the organization.\nTo identify the associated service principal, we authenticate as the low-privileged user using Connect-MgGraproh. Once we extract the AppId behind Corporate Finance Analytics (Figure 5), we are able to authenticate directly as the service principal with the certificate.\nFigure 5. Extracting the AppId\n_________\nNote: Although CBA is disabled in the tenant (Figure 6), authentication to the service principal using the certificate will still succeed. This is because user-based CBA refers to an interactive, browser-based sign-in experience, while service principals rely on a non-interactive OAuth 2.0 client credentials flow using certificate assertions. Disabling CBA affects only interactive user authentication with certificates and has no impact on programmatic service principal authentication. These are separate authentication paths in the Entra ID platform.\nFigure 6. CBA is disabled in this Entra ID tenant\n_________\nStep 2: Discovering app permissions and building our attack path After authenticating as the service principal using the certificate, we check its roles claim in the granted JWT via the Get-MgContext command and discover that it holds AppRoleAssignment.ReadWrite.All (Figure 7).This permission allows the service principal to assign ANY application roles across all service principals—including to itself.\nFigure 7. Checking the service principal’s roles claim\nTo escalate, we enumerate the Microsoft Graph service principal (GraphAggregatorService), which contains all assignable OAuth roles and is present in every Entra tenant as a first-party application. It’s instantiated from a global application registration hosted in Microsoft’s own tenant and can be identified by the static AppId of 00000003-0000-0000-c000-000000000000. Like all multi-tenant applications, it appears in each customer tenant as a **local service principal—**the actual identity used to enforce access control. (We touched on the Entra ID application model in Scenario 1.)\nThe AppId in Figure 8 points to the global definition of Microsoft Graph, which contains all assignable OAuth roles that define app-only permission scopes like Directory.Read.All or RoleManagement.ReadWrite.Directory. Each tenant holds a local service principal instance of the global app, and OAuth permissions are assigned at the service principal level via AppRoleAssignment. This allows applications to operate independently of users, with the scopes defined in the global app manifest but enforced by the tenant-local service principal.\nFigure 8. Enumerating Graph’s assignable OAuth permissions\nFun fact: There are currently 576 unique Graph permissions!\nNow that we’ve located the Microsoft Graph service principal and have its assignable OAuth permissions, the next step is choosing which permission to escalate with. The most impactful for our attack purpose is RoleManagement.ReadWrite.Directory, according to a note on the official documentation:\nFigure 9. Microsoft’s warning about permissions that allow granting authorization\nThis level of access is dangerous by design. It gives full programmatic control over Entra ID role management APIs and supports direct privilege escalation without user interaction.\nStep 3: Assigning dangerous permissions We can assign this permission to our compromised service principal using the following commands:\n1 2 3 4 5 6 7 8 9 10 11 12 13 $roleManagementRole = $graphSP.AppRoles | Where-Object { $\\_.Value -eq \"RoleManagement.ReadWrite.Directory\" } $appRoleAssignmentParams = @{ PrincipalId = $SP.Id ResourceId = $graphSP.Id AppRoleId = $roleManagementRole.Id } New-MgServicePrincipalAppRoleAssignment -ServicePrincipalId $SP.Id -BodyParameter $appRoleAssignmentParams After this command has been executed—although we successfully granted the service principal the RoleManagement.ReadWrite.Directory permission, as inspected by Get-MgContext—we observe no change in the current security context (Figure 10). This is an expected behavior.\nFigure 10. Observing no change in the service principal’s security context\nAccess tokens issued by Entra ID are like static snapshots of claims granted at the time the token was issued. When Connect-MgGraph is executed, it acts as an OAuth2.0 client and initiates an authentication flow against the token endpoint (https://login.microsoftonline.com/{tenant-id}/oauth2/v2.0/token). This endpoint validates the presented credentials and issues a signed JWT access token for it with the caller’s claims (like app roles, scopes, and tenant context) based on the current authorization state at the time of request.\nBecause access tokens are not dynamically refreshed when permissions change, newly granted app roles (like the one we just added) won’t show up until a new token is explicitly obtained. To get the updated privileges, we have to terminate the existing session (Disconnect-MgGraph) and re-authenticate to it (Connect-MgGraph) to trigger the issue of a fresh access token that includes the new claims (Figure 11).\nFigure 11. Triggering the issue of a fresh access token\nWith the RoleManagement.ReadWrite.Directory permission granted, the service principal we have can now modify directory role assignments for any identity in the tenant—including adding itself to the Global Administrator role:\n1 2 3 4 5 6 7 8 9 10 11 $globalAdminRoleId = \"62e90394-69f5-4237-9190-012177145e10\" # GA role GUID $globalAdminRole = Get-MgDirectoryRole -Filter \"roleTemplateId eq '$globalAdminRoleId'\" -ErrorAction SilentlyContinue $roleMemberParams = @{ \"@odata.id\" = \"https://graph.microsoft.com/v1.0/servicePrincipals/$($SP.Id)\" } New-MgDirectoryRoleMemberByRef -DirectoryRoleId $globalAdminRole.Id -BodyParameter $roleMemberParams Now, if we check the assigned roles the compromised service principal has, we will be able to see the GUID of the Global Administrator (Figure 12).\nFigure 12. Viewing the Global Administrator’s GUID\nIf you followed closely, a key behavioral difference may stand out:\nWhy is it necessary to obtain a new JWT for the identity after granting an app permission but not after assigning a directory role?\nThe answer lies in how Entra ID enforces these two models of authorization:\nApplication permissions (such as RoleManagement.ReadWrite.Directory) are issued as static claims within the JWT access token at the time of authentication. These permissions are represented in the roles array claim (or scp in delegated flows). The token is in fact a cryptographically signed assertion reflecting the caller’s app roles and scopes at issuance and usually any changes to these permissions require token reissuance. Directory roles (such as Global Administrator) are also issued as static claims within the access token but follow a different enforcement model. While tokens can include directory role assignments via the wids claim or the group claim (in case of group membership), most Microsoft APIs usually evaluate these roles dynamically at runtime. When a request is made, the backend queries the current role assignments in Entra ID for the caller’s object ID. This real-time lookup allows newly assigned roles to take effect immediately without requiring token renewal. With that being said, Microsoft explicitly notes in its access token claims reference documentation that:\n“The roles, groups, scp, and wids claims are not an exhaustive list of how a resource might authorize a user or application, nor are they an exhaustive list of permissions granted to the caller. The target resource may use another method to authorize access to its protected resources.”\nStep 4: Pivoting to an admin session With the GA role assigned to our service principal, we now possess full directory-level privileges. This allows us to reset the target admin user’s password and assume their identity (Figure 13).\nFigure 13. Assuming the identity of our target admin user\nTo recap the final step, we won’t use TAP or the Azure portal like we did in Scenario 1.\nInstead, we’ll leverage BARK’s1 Get-MSGraphTokenWithUsernamePassword function to authenticate to Microsoft Graph with the new admin credentials and retrieve the flag from the /me endpoint (Figure 14)—staying true to this scenario’s title: Graph Me the Crown (and Roles).\nFigure 14. The flag is captured\nOnce the scenario is completed, we execute the cleanup script (Figure 15) to restore the tenant to its original state.\nFigure 15. EntraGoat cleanup sets us up for our next scenario\nConclusion This scenario illustrates how app-only Graph permissions combined with certificate-based authentication may create blind spots in traditional identity governance.\nNo user compromise is necessary. No interactive flow is required. By chaining two Graph permissions - AppRoleAssignment.ReadWrite.All and RoleManagement.ReadWrite.Directory, the attacker silently escalates a service principal into a Global Administrator.\nSecurity teams must treat application permissions and service principal credentials as critical assets, not secondary identities. Enforcing tight governance over certificate use and Graph permission assignment is essential to prevent headless privilege escalation like the one modeled here in Scenario 2.\nRelated resources App Consent Attack: Hidden Consent GrantPrivilege Elevation in Entra ID: UnOAuthorized | Semperis Research\nNew nOAuth Abuse Alert: Entra Cross-Tenant Saas Apps at Risk\nSecuring Hybrid Identity - Semperis\nEndnotes 1 https://github.com/BloodHoundAD/BARK\nDisclaimer This content is provided for educational and informational purposes only. It is intended to promote awareness and responsible remediation of security vulnerabilities that may exist on systems you own or are authorized to test. Unauthorized use of this information for malicious purposes, exploitation, or unlawful access is strictly prohibited. We do not endorse or condone any illegal activity and disclaims any liability arising from misuse of the material. Additionally, We do not guarantee the accuracy or completeness of the content and assumes no liability for any damages resulting from its use.\n",
  "wordCount" : "2540",
  "inLanguage": "en",
  "image": "http://localhost:1313/images/tomer.jpg","datePublished": "2025-08-10T00:14:27+03:00",
  "dateModified": "2025-08-10T00:14:27+03:00",
  "author":[{
    "@type": "Person",
    "name": "Tomer Nahum"
  }, {
    "@type": "Person",
    "name": "Jonathan Elkabas"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/scenario2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "TomerN",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="TomerN (Alt + H)">TomerN</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/opensourceprojects/" title="Open Source Projects">
                    <span>Open Source Projects</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      EntraGoat Scenario 2: Exploiting App-Only Graph Permissions in Entra ID
    </h1>
    <div class="post-meta"><span title='2025-08-10 00:14:27 +0300 IDT'>August 10, 2025</span>&nbsp;·&nbsp;Tomer Nahum, Jonathan Elkabas

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#graph-me-the-crown-and-roles" aria-label="Graph Me the Crown (and Roles)">Graph Me the Crown (and Roles)</a><ul>
                        
                <li>
                    <a href="#attack-path-overview" aria-label="Attack path overview">Attack path overview</a></li>
                <li>
                    <a href="#attack-flow" aria-label="Attack flow">Attack flow</a></li>
                <li>
                    <a href="#how-does-this-attack-bypass-normal-authentication-controls" aria-label="How does this attack bypass normal authentication controls?">How does this attack bypass normal authentication controls?</a></li>
                <li>
                    <a href="#how-to-detect-and-defend-against-misuse-of-app-only-authentication" aria-label="How to detect and defend against misuse of app-only authentication">How to detect and defend against misuse of app-only authentication</a></li></ul>
                </li>
                <li>
                    <a href="#scenario-deep-dive-step-by-step-solution-walkthrough" aria-label="Scenario deep dive: Step-by-step solution walkthrough">Scenario deep dive: Step-by-step solution walkthrough</a><ul>
                        
                <li>
                    <a href="#step-1-initial-foothold-with-a-compromised-certificate" aria-label="Step 1: Initial foothold with a compromised certificate">Step 1: Initial foothold with a compromised certificate</a></li>
                <li>
                    <a href="#step-2-discovering-app-permissions-and-building-our-attack-path" aria-label="Step 2: Discovering app permissions and building our attack path">Step 2: Discovering app permissions and building our attack path</a></li>
                <li>
                    <a href="#step-3-assigning-dangerous-permissions" aria-label="Step 3: Assigning dangerous permissions">Step 3: Assigning dangerous permissions</a></li>
                <li>
                    <a href="#step-4-pivoting-to-an-admin-session" aria-label="Step 4: Pivoting to an admin session">Step 4: Pivoting to an admin session</a></li></ul>
                </li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a></li>
                <li>
                    <a href="#related-resources" aria-label="Related resources">Related resources</a></li>
                <li>
                    <a href="#endnotes" aria-label="Endnotes">Endnotes</a></li>
                <li>
                    <a href="#disclaimer" aria-label="Disclaimer">Disclaimer</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="graph-me-the-crown-and-roles">Graph Me the Crown (and Roles)<a hidden class="anchor" aria-hidden="true" href="#graph-me-the-crown-and-roles">#</a></h2>
<p>EntraGoat Scenario 2 demonstrates how certificate-based authentication tied to an existing service principal and overprivileged application permissions can lead to Global Administrator compromise.</p>
<p>The attacker starts with access to a leaked certificate that was exposed through continuous integration/continuous delivery (CI/CD) pipeline artifacts. The certificate is valid for a service principal that has the AppRoleAssignment.ReadWrite.All application permission.</p>
<p>By authenticating in an app-only context, the attacker abuses this permission to assign another permission, RoleManagement.ReadWrite.Directory, to the same service principal. This enables the service principal to self-assign any directory role (including Global Administrator) to any service principal it wishes. Finally, the attacker resets the admin’s password and retrieves the scenario flag.</p>
<p>This scenario emphasizes the risks of certificate sprawl, overprivileged Graph scopes, and the nature of app-only tokens. It also highlights the distinction between permission enforcement via token claims vs. real-time directory evaluation, which we’ll explain in this walkthrough.</p>
<h3 id="attack-path-overview">Attack path overview<a hidden class="anchor" aria-hidden="true" href="#attack-path-overview">#</a></h3>
<ol>
<li><strong>Initial foothold</strong>: The attacker obtains a base64-encoded certificate and its password, reportedly leaked through CI/CD pipeline reconnaissance.</li>
<li><strong>Identification</strong>: The certificate matches an existing service principal named Corporate Finance Analytics.</li>
<li><strong>Permission abuse</strong>: The attacker authenticates using the certificate and discovers that the service principal has AppRoleAssignment.ReadWrite.All application permission.</li>
<li><strong>Privilege escalation</strong>: The attacker uses this permission to assign RoleManagement.ReadWrite.Directory to the same service principal.</li>
<li><strong>Role takeover: With directory role management access, the attacker adds the service principal as a member of the Global Administrator directory role.</strong></li>
<li><strong>Account compromise</strong>: The attacker resets the Global Admin user’s password and authenticates to retrieve the flag.</li>
</ol>
<h3 id="attack-flow">Attack flow<a hidden class="anchor" aria-hidden="true" href="#attack-flow">#</a></h3>
<p><em>Figure 1</em> shows the flow of this attack.</p>
<p><img loading="lazy" src="/posts/scenario2/image.png"></p>
<p><em>Figure 1. Flow of the Graph Me the Crown (and Roles) attack scenario</em></p>
<h3 id="how-does-this-attack-bypass-normal-authentication-controls">How does this attack bypass normal authentication controls?<a hidden class="anchor" aria-hidden="true" href="#how-does-this-attack-bypass-normal-authentication-controls">#</a></h3>
<p>This scenario abuses Microsoft Entra ID’s application model, where apps consist of a global registration and a tenant-local service principal. App-only permissions are <strong>requested</strong> at the application registration level and <strong>granted</strong> at the service principal level. In addition, service principals can authenticate independently of users using the OAuth 2.0 client credentials flow.</p>
<p>When a valid certificate is registered for a service principal (at its keyCredentials.customKeyIdentifier property), it can be used to authenticate without interactive input or multifactor authentication (MFA). This app-only authentication path operates outside user-centric protections, allowing a compromised certificate to directly access Graph APIs with the permissions or roles assigned to the service principal.</p>
<p>This attack path combines:</p>
<ul>
<li>Weak certificate hygiene (less relevant for Entra ID)</li>
<li>Excessive and unmonitored app permissions</li>
<li>The intentional design of AppRoleAssignment.ReadWrite.All to bypass* the admin consent experience in app-only contexts</li>
</ul>
<p>By chaining these conditions, attackers can authenticate as a service principal, escalate to sensitive Graph scopes like RoleManagement.ReadWrite.Directory to grant themselves a privileged role (up to Global Administrator) without ever touching a user session after they gained the service principal’s credentials.</p>
<p>____</p>
<p><strong>Note:</strong> Additional attack paths can be chained to this one, as any identity with Application Administrator or Cloud Application Administrator roles, or any service principal with the Application.ReadWrite.All app role or ownership over the target service principal—as demonstrated in Scenario 1—can also take advantage of this attack path by adding credentials for backdoor access to the service principal.</p>
<p>____</p>
<p>Finally, it’s important to distinguish between <strong>different uses of certificate-based authentication</strong> (CBA). When CBA configuration is disabled at the tenant level, that restriction applies only to interactive user authentication—not OAuth client assertions flow for applications. Service principals can still authenticate using certificates if a valid credential is registered in their KeyCredentials property. Entra ID treats this as a separate authentication mechanism. This architectural decoupling may lead to false assumptions about the enforcement of tenant-wide certificate policies.</p>
<p>*In fact, this permission doesn&rsquo;t &ldquo;bypass&rdquo; admin consent - it <strong>IS</strong> admin consent. The permission itself requires admin consent to be granted initially, then enables the holder (and adversaries, of course) to <strong>programmatically grant consent to other applications</strong> as part of machine-to-machine interaction.</p>
<h3 id="how-to-detect-and-defend-against-misuse-of-app-only-authentication">How to detect and defend against misuse of app-only authentication<a hidden class="anchor" aria-hidden="true" href="#how-to-detect-and-defend-against-misuse-of-app-only-authentication">#</a></h3>
<p>Defensive posture in Entra ID must focus on restricting the use of broad app permissions and closely monitoring service principals that hold sensitive roles like AppRoleAssignment.ReadWrite.All and RoleManagement.ReadWrite.Directory.</p>
<p>Security teams should:</p>
<ul>
<li>Regularly audit service principals for high-privilege app roles</li>
<li>Track creation of new credentials on service principals, especially when done outside approved automation</li>
<li>Detect changes to app role assignments that could allow privilege escalation</li>
</ul>
<h2 id="scenario-deep-dive-step-by-step-solution-walkthrough">Scenario deep dive: Step-by-step solution walkthrough<a hidden class="anchor" aria-hidden="true" href="#scenario-deep-dive-step-by-step-solution-walkthrough">#</a></h2>
<p>Let’s take a look at the steps to simulate bypass of authentication controls and understand how it enables Global Admin compromise.</p>
<h3 id="step-1-initial-foothold-with-a-compromised-certificate">Step 1: Initial foothold with a compromised certificate<a hidden class="anchor" aria-hidden="true" href="#step-1-initial-foothold-with-a-compromised-certificate">#</a></h3>
<p>We begin Scenario 2 with a compromised certificate (<em>Figure 2</em>), allegedly dumped during CI/CD pipeline reconnaissance. It&rsquo;s base64-encoded, password-protected, and left behind like cargo falling off a DevOps truck.</p>
<p><img loading="lazy" src="/posts/scenario2/image%201.png"></p>
<p><em>Figure 2. A compromised certificate, dumped in our lap</em></p>
<p>To identify the owner of the certificate, we first decode it into a usable X509Certificate2 object and inspect its metadata:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="nv">$certBase64</span> <span class="p">=</span> <span class="s2">&#34;[BASE64\_CERTIFICATE\_BLOG]&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$certPassword</span> <span class="p">=</span> <span class="s2">&#34;GoatAccess!123&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$certBytes</span> <span class="p">=</span> <span class="p">[</span><span class="no">System.Convert</span><span class="p">]::</span><span class="n">FromBase64String</span><span class="p">(</span><span class="nv">$certBase64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$cert</span> <span class="p">=</span> <span class="nb">New-Object</span> <span class="n">System</span><span class="p">.</span><span class="py">Security</span><span class="p">.</span><span class="py">Cryptography</span><span class="p">.</span><span class="py">X509Certificates</span><span class="p">.</span><span class="py">X509Certificate2</span><span class="p">(</span><span class="nv">$certBytes</span><span class="p">,</span> <span class="nv">$certPassword</span><span class="p">,</span> <span class="p">[</span><span class="no">System.Security.Cryptography.X509Certificates.X509KeyStorageFlags</span><span class="p">]::</span><span class="n">Exportable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$cert</span> <span class="p">|</span> <span class="nb">Select-Object</span> <span class="n">Subject</span><span class="p">,</span> <span class="n">Issuer</span><span class="p">,</span> <span class="n">Thumbprint</span><span class="p">,</span> <span class="n">NotBefore</span><span class="p">,</span> <span class="n">NotAfter</span> <span class="p">|</span> <span class="nb">Format-List</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>We can see that the certificate is self-signed and issued for an app called Corporate Finance Analytics (<em>Figure 3</em>).</p>
<p><img loading="lazy" src="/posts/scenario2/image%202.png"></p>
<p><em>Figure 3. Identifying the app our certificate is issued for</em></p>
<p>Alternatively, we can iterate through all application registrations in the tenant and search for a matching certificate thumbprint. Each application object in Entra ID has a KeyCredentials attribute, which holds metadata about certificates or public keys associated with the app that is used for authentication in app-only contexts. Each entry includes a CustomKeyIdentifier, which stores the certificate&rsquo;s thumbprint (<em>Figure 4</em>) in binary form and allows for lookup or correlation against known certificates.</p>
<p><img loading="lazy" src="/posts/scenario2/image%203.png"></p>
<p><em>Figure 4. Certificate thumbprint</em></p>
<p>The following function can perform the search:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="kd">function</span><span class="w"> </span><span class="nb">Find-AppRegistrationByThumbprint</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">param</span><span class="p">([</span><span class="no">string</span><span class="p">]</span><span class="nv">$Thumbprint</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c"># Get all application registrations and check for matching certificate thumbprint</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">$allApps</span> <span class="p">=</span> <span class="nb">Get-MgApplication</span> <span class="n">-All</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="p">(</span><span class="nv">$app</span> <span class="k">in</span> <span class="nv">$allApps</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nv">$app</span><span class="p">.</span><span class="n">KeyCredentials</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="p">(</span><span class="nv">$keyCred</span> <span class="k">in</span> <span class="nv">$app</span><span class="p">.</span><span class="n">KeyCredentials</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c"># Compare thumbprints (certificate matching)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="nv">$keyCred</span><span class="p">.</span><span class="n">CustomKeyIdentifier</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="nv">$credThumbprint</span> <span class="p">=</span> <span class="p">[</span><span class="no">System.Convert</span><span class="p">]::</span><span class="n">ToHexString</span><span class="p">(</span><span class="nv">$keyCred</span><span class="p">.</span><span class="n">CustomKeyIdentifier</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="nv">$credThumbprint</span> <span class="o">-eq</span> <span class="nv">$Thumbprint</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        <span class="nb">Write-Host</span> <span class="s2">&#34;Certificate match found for: </span><span class="p">$(</span><span class="nv">$app</span><span class="p">.</span><span class="n">DisplayName</span><span class="p">)</span><span class="s2">&#34;</span> <span class="n">-ForegroundColor</span> <span class="n">Cyan</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        <span class="k">return</span> <span class="nv">$app</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="vm">$null</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Microsoft Graph never stores or returns the actual certificate content or private keys. Querying the KeyCredential attribute using Graph API only reveals the registered certificate metadata, never the certificate itself, no matter how high the privileges the requesting identity has. This reinforces the critical need for secure handling and storage of private keys throughout the organization.</p>
<p>To identify the associated service principal, we authenticate as the low-privileged user using Connect-MgGraproh. Once we extract the AppId behind Corporate Finance Analytics (<em>Figure 5</em>), we are able to authenticate directly as the service principal with the certificate.</p>
<p><img loading="lazy" src="/posts/scenario2/image%204.png"></p>
<p><em>Figure 5. Extracting the AppId</em></p>
<p>_________</p>
<p><strong>Note</strong>: Although <strong>CBA is</strong> <strong>disabled</strong> in the tenant (<em>Figure 6</em>), authentication to the service principal using the certificate will still succeed. This is because <strong>user-based CBA refers to an interactive, browser-based sign-in experience, while service principals rely on a non-interactive OAuth 2.0 client credentials flow using certificate assertions.</strong> Disabling CBA affects only interactive user authentication with certificates and has no impact on programmatic service principal authentication. These are separate authentication paths in the Entra ID platform.</p>
<p><img loading="lazy" src="/posts/scenario2/image%205.png"></p>
<p><em>Figure 6. CBA is disabled in this Entra ID tenant</em></p>
<p>_________</p>
<h3 id="step-2-discovering-app-permissions-and-building-our-attack-path">Step 2: Discovering app permissions and building our attack path<a hidden class="anchor" aria-hidden="true" href="#step-2-discovering-app-permissions-and-building-our-attack-path">#</a></h3>
<p>After authenticating as the service principal using the certificate, we check its roles claim in the granted JWT via the Get-MgContext command and discover that it holds AppRoleAssignment.ReadWrite.All (<em>Figure 7</em>).This permission allows the service principal to assign ANY application roles across all service principals—including to itself.</p>
<p><img loading="lazy" src="/posts/scenario2/image%206.png"></p>
<p><em>Figure 7. Checking the service principal’s roles claim</em></p>
<p>To escalate, we enumerate the Microsoft Graph service principal (GraphAggregatorService), which contains all assignable OAuth roles and is present in every Entra tenant as a first-party application. It’s instantiated from a global application registration hosted in Microsoft’s own tenant and can be identified by the static AppId of 00000003-0000-0000-c000-000000000000. Like all multi-tenant applications, it appears in each customer tenant as a **local service principal—**the actual identity used to enforce access control. (We touched on the Entra ID application model in Scenario 1.)</p>
<p>The AppId in <em>Figure 8</em> points to the global definition of Microsoft Graph, which contains all assignable OAuth roles that define app-only permission scopes like Directory.Read.All or RoleManagement.ReadWrite.Directory. Each tenant holds a local service principal instance of the global app, and <strong>OAuth permissions are assigned at the service principal level</strong> via AppRoleAssignment. This allows applications to operate independently of users, with the scopes defined in the global app manifest but enforced by the tenant-local service principal.</p>
<p><img loading="lazy" src="/posts/scenario2/image%207.png"></p>
<p><em>Figure 8. Enumerating Graph’s assignable OAuth permissions</em></p>
<p><strong>Fun fact:</strong> There are currently 576 unique Graph permissions!</p>
<p>Now that we&rsquo;ve located the Microsoft Graph service principal and have its assignable OAuth permissions, the next step is choosing <strong>which permission to escalate with</strong>. The most impactful for our attack purpose is RoleManagement.ReadWrite.Directory, according to a note on the official <a href="https://learn.microsoft.com/en-us/graph/permissions-reference#rolemanagementreadwritedirectory">documentation</a>:</p>
<p><img loading="lazy" src="/posts/scenario2/image%208.png"></p>
<p><em>Figure 9. Microsoft’s warning about permissions that allow granting authorization</em></p>
<p>This level of access is <strong>dangerous by design</strong>. It gives full programmatic control over Entra ID role management APIs and supports direct privilege escalation without user interaction.</p>
<h3 id="step-3-assigning-dangerous-permissions">Step 3: Assigning dangerous permissions<a hidden class="anchor" aria-hidden="true" href="#step-3-assigning-dangerous-permissions">#</a></h3>
<p>We can assign this permission to our compromised service principal using the following commands:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="nv">$roleManagementRole</span> <span class="p">=</span> <span class="nv">$graphSP</span><span class="p">.</span><span class="py">AppRoles</span> <span class="p">|</span> <span class="nb">Where-Object</span> <span class="p">{</span> <span class="p">$\</span><span class="n">_</span><span class="p">.</span><span class="py">Value</span> <span class="o">-eq</span> <span class="s2">&#34;RoleManagement.ReadWrite.Directory&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$appRoleAssignmentParams</span> <span class="p">=</span> <span class="vm">@</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">PrincipalId</span> <span class="p">=</span> <span class="nv">$SP</span><span class="p">.</span><span class="py">Id</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ResourceId</span> <span class="p">=</span> <span class="nv">$graphSP</span><span class="p">.</span><span class="py">Id</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">AppRoleId</span> <span class="p">=</span> <span class="nv">$roleManagementRole</span><span class="p">.</span><span class="py">Id</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">New-MgServicePrincipalAppRoleAssignment</span> <span class="n">-ServicePrincipalId</span> <span class="nv">$SP</span><span class="p">.</span><span class="py">Id</span> <span class="n">-BodyParameter</span> <span class="nv">$appRoleAssignmentParams</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>After this command has been executed—although we successfully granted the service principal the RoleManagement.ReadWrite.Directory permission, as inspected by Get-MgContext—we observe no change in the current security context (<em>Figure 10</em>). This is an expected behavior.</p>
<p><img loading="lazy" src="/posts/scenario2/image%209.png"></p>
<p><em>Figure 10. Observing no change in the service principal’s security context</em></p>
<p>Access tokens issued by Entra ID are like <strong>static snapshots</strong> of claims granted <strong>at the time the token was issued</strong>. When Connect-MgGraph is executed, it acts as an OAuth2.0 client and initiates an authentication flow against the token endpoint (<a href="https://login.microsoftonline.com/%7Btenant-id%7D/oauth2/v2.0/token)">https://login.microsoftonline.com/{tenant-id}/oauth2/v2.0/token)</a>. This endpoint validates the presented credentials and issues a signed JWT access token for it with the caller’s claims (like app roles, scopes, and tenant context) based on the current authorization state at the time of request.</p>
<p>Because access tokens are <strong>not dynamically refreshed</strong> when permissions change, newly granted app roles (like the one we just added) won’t show up until a new token is explicitly obtained. To get the updated privileges, we have to terminate the existing session (Disconnect-MgGraph) and re-authenticate to it (Connect-MgGraph) to trigger the issue of a fresh access token that includes the new claims (<em>Figure 11</em>).</p>
<p><img loading="lazy" src="/posts/scenario2/image%2010.png"></p>
<p><em>Figure 11. Triggering the issue of a fresh access token</em></p>
<p>With the RoleManagement.ReadWrite.Directory permission granted, the service principal we have can now <strong>modify directory role assignments</strong> <strong>for any identity</strong> in the tenant—including adding itself to the Global Administrator role:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="nv">$globalAdminRoleId</span> <span class="p">=</span> <span class="s2">&#34;62e90394-69f5-4237-9190-012177145e10&#34;</span> <span class="c"># GA role GUID</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$globalAdminRole</span> <span class="p">=</span> <span class="nb">Get-MgDirectoryRole</span> <span class="n">-Filter</span> <span class="s2">&#34;roleTemplateId eq &#39;</span><span class="nv">$globalAdminRoleId</span><span class="s2">&#39;&#34;</span> <span class="n">-ErrorAction</span> <span class="n">SilentlyContinue</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$roleMemberParams</span> <span class="p">=</span> <span class="vm">@</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;@odata.id&#34;</span> <span class="p">=</span> <span class="s2">&#34;https://graph.microsoft.com/v1.0/servicePrincipals/</span><span class="p">$(</span><span class="nv">$SP</span><span class="p">.</span><span class="n">Id</span><span class="p">)</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">New-MgDirectoryRoleMemberByRef</span> <span class="n">-DirectoryRoleId</span> <span class="nv">$globalAdminRole</span><span class="p">.</span><span class="py">Id</span> <span class="n">-BodyParameter</span> <span class="nv">$roleMemberParams</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Now, if we check the assigned roles the compromised service principal has, we will be able to see the GUID of the Global Administrator (<em>Figure 12</em>).</p>
<p><img loading="lazy" src="/posts/scenario2/image%2011.png"></p>
<p><em>Figure 12. Viewing the Global Administrator’s GUID</em></p>
<p>If you followed closely, a key behavioral difference may stand out:</p>
<p><strong>Why is it necessary to obtain a new JWT for the identity after granting an app permission but not after assigning a directory role?</strong></p>
<p>The answer lies in how Entra ID enforces these two models of authorization:</p>
<ul>
<li><strong>Application permissions</strong> (such as RoleManagement.ReadWrite.Directory) are issued as static claims within the JWT access token at the time of authentication. These permissions are represented in the roles array claim (or scp in delegated flows). The token is in fact a cryptographically signed assertion reflecting the caller’s app roles and scopes at issuance and usually any changes to these permissions require token reissuance.</li>
<li><strong>Directory roles</strong> (such as Global Administrator) are also issued as static claims within the access token but follow a different enforcement model. While tokens can include directory role assignments via the wids claim or the group claim (in case of group membership), most Microsoft APIs <em><strong>usually</strong></em> evaluate these roles dynamically at runtime. When a request is made, the backend queries the current role assignments in Entra ID for the caller’s object ID. This real-time lookup allows newly assigned roles to take effect immediately without requiring token renewal.</li>
</ul>
<p>With that being said, Microsoft explicitly notes in its <a href="https://learn.microsoft.com/en-us/entra/identity-platform/access-token-claims-reference">access token claims reference</a> documentation that:</p>
<blockquote>
<p>“The <em>roles</em>, <em>groups</em>, <em>scp</em>, and <em>wids</em> claims are not an exhaustive list of how a resource might authorize a user or application, nor are they an exhaustive list of permissions granted to the caller. The target resource may use another method to authorize access to its protected resources.”</p></blockquote>
<h3 id="step-4-pivoting-to-an-admin-session">Step 4: Pivoting to an admin session<a hidden class="anchor" aria-hidden="true" href="#step-4-pivoting-to-an-admin-session">#</a></h3>
<p>With the GA role assigned to our service principal, we now possess full directory-level privileges. This allows us to reset the target admin user’s password and assume their identity (Figure 13).</p>
<p><img loading="lazy" src="/posts/scenario2/image%2012.png"></p>
<p><em>Figure 13. Assuming the identity of our target admin user</em></p>
<p>To recap the final step, we won’t use TAP or the Azure portal like we did in Scenario 1.</p>
<p>Instead, we&rsquo;ll leverage BARK’s1 Get-MSGraphTokenWithUsernamePassword function to authenticate to Microsoft Graph with the new admin credentials and retrieve the flag from the /me endpoint (<em>Figure 14</em>)—staying true to this scenario’s title: <strong>Graph Me the Crown (and Roles)</strong>.</p>
<p><img loading="lazy" src="/posts/scenario2/image%2013.png"></p>
<p><em>Figure 14. The flag is captured</em></p>
<p>Once the scenario is completed, we execute the cleanup script (<em>Figure 15</em>) to restore the tenant to its original state.</p>
<p><img loading="lazy" src="/posts/scenario2/image%2014.png"></p>
<p><em>Figure 15. EntraGoat cleanup sets us up for our next scenario</em></p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>This scenario illustrates how app-only Graph permissions combined with certificate-based authentication may create blind spots in traditional identity governance.</p>
<p>No user compromise is necessary. No interactive flow is required. By chaining two Graph permissions - AppRoleAssignment.ReadWrite.All and RoleManagement.ReadWrite.Directory, the attacker silently escalates a service principal into a Global Administrator.</p>
<p>Security teams must treat application permissions and service principal credentials as critical assets, not secondary identities. Enforcing tight governance over certificate use and Graph permission assignment is essential to prevent headless privilege escalation like the one modeled here in Scenario 2.</p>
<h2 id="related-resources">Related resources<a hidden class="anchor" aria-hidden="true" href="#related-resources">#</a></h2>
<p><a href="https://www.semperis.com/blog/app-consent-attack-hidden-consent-grant">App Consent Attack: Hidden Consent Grant</a><a href="https://www.semperis.com/blog/unoauthorized-privilege-elevation-through-microsoft-applications/">Privilege Elevation in Entra ID: UnOAuthorized | Semperis Research</a></p>
<p><a href="https://www.semperis.com/blog/noauth-abuse-alert-full-account-takeover/">New nOAuth Abuse Alert: Entra Cross-Tenant Saas Apps at Risk</a></p>
<p><a href="https://www.semperis.com/blog/securing-hybrid-identity/?utm_medium=pd&amp;utm_source=bing&amp;utm_campaign=brand">Securing Hybrid Identity - Semperis</a></p>
<h2 id="endnotes">Endnotes<a hidden class="anchor" aria-hidden="true" href="#endnotes">#</a></h2>
<p>1 <a href="https://github.com/BloodHoundAD/BARK">https://github.com/BloodHoundAD/BARK</a></p>
<h2 id="disclaimer">Disclaimer<a hidden class="anchor" aria-hidden="true" href="#disclaimer">#</a></h2>
<p>This content is provided for educational and informational purposes only. It is intended to promote awareness and responsible remediation of security vulnerabilities that may exist on systems you own or are authorized to test. Unauthorized use of this information for malicious purposes, exploitation, or unlawful access is strictly prohibited. We do not endorse or condone any illegal activity and disclaims any liability arising from misuse of the material. Additionally, We do not guarantee the accuracy or completeness of the content and assumes no liability for any damages resulting from its use.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/scenario6/">
    <span class="title">« Prev</span>
    <br>
    <span>EntraGoat Scenario 6: Exploiting Chained Misconfigurations to Impersonate Global Admin in Entra ID</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/scenario1/">
    <span class="title">Next »</span>
    <br>
    <span>EntraGoat Scenario 1: Application Ownership Compromise in Entra ID</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share EntraGoat Scenario 2: Exploiting App-Only Graph Permissions in Entra ID on x"
            href="https://x.com/intent/tweet/?text=EntraGoat%20Scenario%202%3a%20Exploiting%20App-Only%20Graph%20Permissions%20in%20Entra%20ID&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fscenario2%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share EntraGoat Scenario 2: Exploiting App-Only Graph Permissions in Entra ID on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fscenario2%2f&amp;title=EntraGoat%20Scenario%202%3a%20Exploiting%20App-Only%20Graph%20Permissions%20in%20Entra%20ID&amp;summary=EntraGoat%20Scenario%202%3a%20Exploiting%20App-Only%20Graph%20Permissions%20in%20Entra%20ID&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fscenario2%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share EntraGoat Scenario 2: Exploiting App-Only Graph Permissions in Entra ID on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fscenario2%2f&title=EntraGoat%20Scenario%202%3a%20Exploiting%20App-Only%20Graph%20Permissions%20in%20Entra%20ID">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share EntraGoat Scenario 2: Exploiting App-Only Graph Permissions in Entra ID on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fscenario2%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share EntraGoat Scenario 2: Exploiting App-Only Graph Permissions in Entra ID on whatsapp"
            href="https://api.whatsapp.com/send?text=EntraGoat%20Scenario%202%3a%20Exploiting%20App-Only%20Graph%20Permissions%20in%20Entra%20ID%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fscenario2%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share EntraGoat Scenario 2: Exploiting App-Only Graph Permissions in Entra ID on telegram"
            href="https://telegram.me/share/url?text=EntraGoat%20Scenario%202%3a%20Exploiting%20App-Only%20Graph%20Permissions%20in%20Entra%20ID&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fscenario2%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share EntraGoat Scenario 2: Exploiting App-Only Graph Permissions in Entra ID on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=EntraGoat%20Scenario%202%3a%20Exploiting%20App-Only%20Graph%20Permissions%20in%20Entra%20ID&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fscenario2%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">TomerN</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
